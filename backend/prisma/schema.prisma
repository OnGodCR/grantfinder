// Prisma schema for GrantFinder â€” array-based embeddings (no pgvector)

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["debian-openssl-1.1.x", "native"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Institution {
  id                   String   @id @default(cuid())
  name                 String
  domain               String?
  plan                 String   @default("starter")
  seats                Int      @default(10)
  stripeCustomerId     String?
  stripeSubscriptionId String?
  createdAt            DateTime @default(now())

  users        User[]
  collections  SavedCollection[]
  searchLogs   SearchLog[]
}

enum Role {
  ADMIN
  RESEARCHER
}

model User {
  id            String   @id @default(cuid())
  clerkUserId   String   @unique
  email         String
  name          String?
  role          Role     @default(RESEARCHER)
  institutionId String
  createdAt     DateTime @default(now())

  institution   Institution   @relation(fields: [institutionId], references: [id])
  profile       ResearcherProfile?
  comments      Comment[]
  notifications Notification[]
  matches       Match[]
  collections   SavedCollection[] @relation("CollectionOwner")
  searchLogs    SearchLog[]
}

model ResearcherProfile {
  id            String   @id @default(cuid())
  userId        String   @unique
  keywords      String[]
  researchAreas String[]
  pastFunding   String[]

  // Array-based embedding
  embedding     Float[]

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user          User     @relation(fields: [userId], references: [id])
}

model Agency {
  id      String  @id @default(cuid())
  name    String  @unique
  country String?
  url     String?
  grants  Grant[]
}

model Grant {
  id          String   @id @default(cuid())
  source      String
  sourceId    String?
  url         String?
  title       String
  description String
  purpose     String?
  currency    String?  @default("USD")
  fundingMin  Float?
  fundingMax  Float?
  deadline    DateTime?
  eligibility String?
  summary     String?

  // Array-based embedding
  embedding   Float[]

  agencyId    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  agency      Agency?  @relation(fields: [agencyId], references: [id])
  items       CollectionItem[]
  matches     Match[]

  @@unique([source, sourceId], name: "source_sourceId")
}

model SavedCollection {
  id            String   @id @default(cuid())
  name          String
  institutionId String
  createdById   String
  createdAt     DateTime @default(now())

  institution   Institution @relation(fields: [institutionId], references: [id])
  createdBy     User        @relation("CollectionOwner", fields: [createdById], references: [id])
  items         CollectionItem[]
  comments      Comment[]
}

model CollectionItem {
  id           String  @id @default(cuid())
  collectionId String
  grantId      String
  note         String?

  collection   SavedCollection @relation(fields: [collectionId], references: [id])
  grant        Grant           @relation(fields: [grantId], references: [id])
}

model Comment {
  id           String   @id @default(cuid())
  collectionId String
  userId       String
  text         String
  createdAt    DateTime @default(now())

  collection   SavedCollection @relation(fields: [collectionId], references: [id])
  user         User            @relation(fields: [userId], references: [id])
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String
  payload   Json
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id])
}

model SearchLog {
  id            String   @id @default(cuid())
  institutionId String
  userId        String
  query         String
  createdAt     DateTime @default(now())

  institution   Institution @relation(fields: [institutionId], references: [id])
  user          User        @relation(fields: [userId], references: [id])
}

model Match {
  id        String   @id @default(cuid())
  userId    String
  grantId   String
  score     Float
  createdAt DateTime @default(now())

  user      User   @relation(fields: [userId], references: [id])
  grant     Grant  @relation(fields: [grantId], references: [id])
}
